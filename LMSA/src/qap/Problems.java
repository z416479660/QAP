package qap;

import java.io.*;
import java.util.Scanner;

/**
 * @author yiwen zhong
 *
 */
public class Problems {
	public static Problems problem = null;
	public static String fileName = null;

	//to open the file generated by myself
	private Problems(String filename) throws FileNotFoundException,IOException {
		FileReader data;
		Scanner scan;

		data = new FileReader(filename);
		scan = new Scanner(data);
		scan.nextInt();
		//to get the number of city
		cityNumber = scan.nextInt();
		//to get the length of best tour
		bestMakespan = scan.nextInt();
		cityDistance = new int[cityNumber][cityNumber];
		for (int i=0; i<cityNumber;i++) {
			//System.out.println("city"+i);
			for (int j=0; j<cityNumber; j++) {
				cityDistance[i][j] = scan.nextInt();
			}
		}
		//to read flow matrix
		flowData = new int[cityNumber][cityNumber];
		for (int i=0; i<cityNumber;i++) {
			//System.out.println("city"+i);
			for (int j=0; j<cityNumber; j++) {
				flowData[i][j] = scan.nextInt();
			}
		}
		scan.close();
		data.close();
		
		final int K = cityNumber * (cityNumber-1) / 2;
		pairs = new int[K][2];
		int i = 0, j =0;
		for (int k = 0; k < K; k++) {
			i = (j == cityNumber-1)? (i+1) : i;
			j = (j == cityNumber-1)? (i+1) % cityNumber : j+1;
			pairs[k][0] = i;
			pairs[k][1] = j;
		}
		//System.out.println(bestMakespan);
	}

	public static Problems getProblem() {
		if (problem == null) {
			try {
				problem = new Problems(fileName);
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return problem;
	}

	public static void setFileName(String fileName) {
		Problems.fileName = fileName;
		try {
			problem = new Problems(fileName);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}


	public String toString() {
		StringBuffer out=new StringBuffer();

		out.append(getCityNumber()+"\n");
		for (int i=0; i<flowData.length; i++) {
			for (int j=0; j<flowData[i].length; j++) {
				out.append(flowData[i][j]+"\t");
			}
			out.append("\n");
		}
		return out.toString();
	}

	public int getCityNumber() { return cityNumber;}
	public int[][] getCityDistance() { return cityDistance;}
	public int[][] getFlowData() { return flowData;}
	public int getBestMakespan() { return bestMakespan;}
	public int[][] getPairs() { return pairs;}
	
	public Facility[] getFacilities() { 
		if (facilities == null) {
			createAverageData();
		}
		return facilities;
	}
	
	public Facility getFacility(int ID) {
		if (facilities == null) {
			createAverageData();
		}
		return facilities[ID];
	}
	
	public Location[] getLocations() {
		if ( locations == null) {
			createAverageData();
		}
		return locations;
	}

	public Location getLocation(int ID) {
		if ( locations == null) {
			createAverageData();
		}
		return locations[ID];
	}
	
	private void createAverageData() {
		facilities = new Facility[cityNumber];
		for (int id = 0; id < facilities.length; id++) {
			double flow = 0;
			for ( int f : flowData[id] ) {
				flow += f;
			}
			facilities[id] = new Facility(id, flow / cityNumber);
		}
		
		locations = new Location[cityNumber];
		for (int id = 0; id < locations.length; id++) {
			double dist = 0;
			for ( int d : cityDistance[id] ) {
				dist += d;
			}
			locations[id] = new Location(id, dist / cityNumber);
		}
	}
	private int bestMakespan;
	private int cityNumber;
	private int[][]cityDistance;
	private int[][] flowData;
	
	private int[][] pairs;
	
	private Facility[] facilities = null;
	private Location[] locations = null;
}

